### Índice

- [3. Tipos primitivos, funções e coisas uteis](#3-tipos-primitivos-funções-e-coisas-uteis)
  - [3.2 Definições](#32-definições)
  - [3.3 Funções](#33-funções)
  - [3.4 Currying](#34-currying)
  - [3.5 Composição](#35-composição)
  - [3.6 Recursão](#36-recursão)
  - [3.7 Funções do Preludio](#37-funções-do-preludio)
  - [3.8 Let e Where](#38-let-e-where)
    - [3.8.1 Let bindings](#381-let-bindings)
    - [3.8.2 Where](#382-where)
    - [3.9 Cast e The](#39-cast-e-the)
    - [3.10 Expressão If](#310-expressão-if)

# 3. Tipos primitivos, funções e coisas uteis

Existe uma distinção importante entre termos e tipos que nós precisamos entender antes de qualquer coisa. Termos são dados que podem ser calculados e que possuem um tipo específico, por exemplo, `2` tem tipo `Int`, onde:

- `2` é um termo;
- `Int` (que significa número inteiro) o tipo do dado, 2.

Os tipos que são padrões e base da linguagem de programação são chamados *tipos primitivos* e, em idris são eles:

- `Int`, para números inteiros;
- `Double`, para números quebrados, como `2.3`, por exemplo;
- `Char`, para um único caractere, como `'b'`, por exemplo;
- `String`, para texto, como `"é lógico pô"`, por exemplo;
- `Bool`, que pode ser `True` ou `False` (verdadeiro ou falso).
- `()`, que pode ser `()`. Esse tipo representa uma unidade e por isso é chamado de Unit. Em muitos casos, ele é utilizado pra representar funções que não retornam nada já que o valor sempre vai ser o mesmo.

**Sentenças de tipos** relacionam tipos e valores colocando dois pontos entre eles. No caso de `2 : Int`, é expressado que `2` é do tipo `Int`.

![Sentenças de tipos](https://i.imgur.com/eF6wrWq.png)

Também existem termos que não foram calculados, como `2 > 3`, sendo esse um termo que relaciona `2` e `3` com a relação de *maior*, resultando em `False` e, assim podemos pensar que `2 > 3 : Bool` já que `False` pertence ao tipo `Bool`.

Exercícios:
- 2.1. Qual o tipo de `True`?
- 2.2. Qual o tipo de `3.14`?
- 2.3. Qual o tipo e o valor final de `10 > 5`?
- 2.4. Digite a **sentença de tipo** sobre `"lagtrain"` pertencente ao tipo `String`.

## 3.2 Definições

Agora que sabemos os tipos primitivos e como dizer que um certo valor pertence a um determinado tipo, é hora de aprendermos a como fazer isso em Idris2 e, além disso, colocar um nome para usarmos depois. No exemplo a baixo, defino que o nome `idade` pertence ao tipo `Int` sendo seu valor `19` e também a mesma coisa que a sentença de tipo `19 : Int`.

```idris
idade : Int 
idade = 19
```

## 3.3 Funções

**Funções** são como máquinas que transformam o valor de entrada - também chamado de **parâmetro** - e retornam outros valores. Em Idris, todas as funções são puras, ou seja, é garantido que não modificarão um valor que não esteja dentro da função. Sendo assim, teoricamente, sempre irão retornar o mesmos valores a partir dos mesmos parâmetros.

<p align="center">
  <img src="https://i.imgur.com/Zb6rTP1.png" width="400px">
</p>

Funções também são termos e possuem tipos. O tipo de uma função que transforma do tipo `String` para o tipo `Int` é `String -> Int`. Em Idris podemos expressar uma função que incrementa em um o número que colocarmos e retornar ele da seguinte forma:

```idris 
sucessor : Int -> Int 
sucessor x = x + 1
```

Na matemática, o equivalente a essa função seria:

```
f(x) = x + 1
```

Obs: Além do `+`, temos outras operações como `-`, `*` (multiplicação) e `/` (divisão).

Como pôde ver, é a mesma coisa que uma definição, porém, o tipo dela agora é o tipo de uma função que recebe `Int` e retorna `Int`, também, a definição inclui um nome a mais que é o `x` (após o nome `sucessor`) que nesse caso representa a nossa entrada e no final ela retorna o valor `x+1`. 

Para aplicarmos essa função, colocamos o valor que queremos que seja substituído no lugar de `x` após o nome da função como, por exemplo : `sucessor 3` que no final irá virar `4`. Se colocarmos o tipo errado (Já que a função pede um Int), a aplicação resultará em um erro.

```idris
Main> sucessor 3
4

Main> sucessor "lol"

Error: Can't find an implementation for FromString Int.

(Interactive):1:10--1:15
 1 | sucessor "lol"
              ^^^^^
```

Um exemplo simples com duas definições seria

```idris
-- Tudo que começa com dois menos é um comentário!
sucessor : Int -> Int 
sucessor x = x + 1

-- Aqui vamos aplicar a função e guardar
quatro : Int 
quatro = sucessor 3
```

No exemplo acima, na definição de `quatro` nós aplicamos a função `sucessor` a `3`, então no final receberemos o valor `4` pertencente ao tipo `Int`.

Funções que recebem dois parâmetros como uma de soma, por exemplo, pode ser definida do mesmo jeito, contudo, usando duas "setas".

```idris
-- Recebe x que é um Int e y que é um Int e retorna um Int
somar : Int -> Int -> Int 
somar x y = x + y
```

Podemos aplicar essa função deste jeito: `somar 3 4` e no final receberemos o valor `7`. 

## 3.4 Currying 

Uma propriedade importante da função somar é que no final ela é a uma função que retorna outra função e nós chamamos isso de **currying**. 

Você: Mas como assim??!!

Então... vamos pensar em algo bem ineficiente, contudo com objetos reais! Imagine uma fábrica que produza uma máquina de tudo que seja possível de se desenhar em uma folha de papel. Nessa fábrica, nós temos primeiro uma máquina que recebe a folha de papel com um desenho e produz outra máquina, porém, essa segunda máquina é especializada a essa tarefa. Isso também acontece com a soma.

Se colocamos na função `somar` apenas o valor `3`, essa função produzá uma versão especializada de soma em que o primeiro número seja sempre `3`. 

<p align="center">
  <img src="https://i.imgur.com/U4Pj8S8.png" width="500px">
</p>

Se produzirmos uma versão "especializada" podemos falar que aplicamos parcialmente a função como no exemplo a baixo:

```idris
maisTres : Int -> Int 
maisTres = somar 3
```

Agora se aplicarmos a função `maisTres` com o número `4`, teremos o valor `7`. 

Exemplo da aplicação de maisTres: `maisTres 4` 

Funções também podem aparecer como valores em uma definição que nem neste exemplo

```idris
-- sucessor é a mesma coisa que receber x e retornar x + 1
sucessor : Int -> Int
sucessor = \x => x + 1
```

## 3.5 Composição

Às vezes nós precisamos executar sequencialmente uma quantidade de funções, tal como `sucessor (metade (predecessor x))` e, para evitar ficar tão verboso, podemos juntar duas ou mais funções em uma só com o incrível operador `.`. O que no começo seria `sucessor (metade (predecessor x))`, podemos expressar apenans como `sucessor . metade . predecessor`.

Você: Mas e o `x`???

Quando nós tentamos compor funções, nós não especificamos uma aplicação para elas já que nós queremos outra função

<p align="center">
  <img src="https://i.imgur.com/EIyG8nv.png" width="500px">
</p>

```idris
-- Soma 1 
suc : Int -> Int
suc x = x + 1

-- Subtrai 1
pred : Int -> Int
pred x = x - 1

-- Soma e subtrai 1, ou seja, não faz nada lol.
nada : Int -> Int 
nada = suc . pred 

-- Soma e subtrai 1, ou seja, não faz nada contudo de maneira feia (sem composição).
nadaFeio : Int -> Int 
nadaFeio x = suc (pred x)
```

## 3.6 Recursão

Recursão é um recurso bem interessante que nos permite fazer loops e repetir a mesma coisa varias vezes dentro de uma função usando ela mesma. Um exemplo que é comumente ensinado no ensino médio sobre recursão, é a função fatorial, que chama a si mesma no formato:

- `f(x) = x * f(x-1)` para x > 1
- `f(x) = x` para x <= 1

Um exemplo da aplicação dessas regras para f(3) seria:
- `f(x) = 3 * f(2)` Primeiro caso
- `f(x) = 3 * f(2 * f(1))` Primeiro caso
- `f(x) = 3 * f(2 * 1)` Segundo caso

A função fatorial tem uma definição parecida em Idris e para isso vamos usar um recurso novo que seria uma definição que caso o valor seja igual ao especificado ela roda.

```idrism
fatorial : Int -> Int
fatorial 1 = 1
fatorial x = x * fatorial (x - 1)
```

Essa definição é bem parecida com a definição que eu forneci usando uma notação mais matemática. Começando na primeira linha, fatorial é uma função que recebe um `Int` e retorna um `Int` e na segunda linha **caso o valor de entrada seja 1** ele irá retornar 1. Para qualquer outro caso `x`, nós iremos ter `x * fatorial (x - 1)` como o valor.

Exercícios:
  - 2.5. Implemente a função fibonnaci em Idris de forma recursiva. Seguindo a definição: 
    `fib(0) = 1` 
    `fib(1) = 1`
    `fib(x) = fib(x-1) + fib(x-2)`
    Um teste rapido seria verificar se fib(10) é igual a 55.

## 3.7 Funções do Preludio

Essa parte vai servir para mostrar algumas operações legais que podemos fazer com dados e varios tipos interessantes.

- **Tuplas**: São como pares de dados, como `(1, 'a') : (Int, Char)`, por exemplo. O termo da tupla é um par composto por um número e um caractere, o tipo correspondente disso é uma tupla de `Int` e `Char`.

- **fst**: Essa função recebe uma tupla de 2 elementos e retorna o primeiro elemento. Exemplo:
  ```idris
  Main> fst (3, 'a')
  3
  ``` 

- **snd**: Essa função recebe uma tupla de 2 elementos e retorna o segundo. Exemplo:
  ```idris
  Main> snd (3, 'a')
  'a'
  ```

- **isDigit** Checa se um caractere é um digito, caso seja, retorna True, caso contrário, False.
  ```idris
  Main> isDigit '3'
  True
  ```

- **strCons** Adiciona um caractere na frente de uma String (texto)
  ```idris
  Main> strCons 'e' " logico po"
  "e logico po"
  ```

- Outras diversas como `not`, `&&`, `||`, `>`, `<`, `>=` e `<=`

Exercícios:
- 2.6. Faça algumas composições entre as funções apresentadas;
- 2.7. Faça uma função recursiva que repita o caractere passado `n` vezes. Por exemplo: <br>
  `replicar 4 'b'` resultar em `"bbbb"`.

  Dica: use `strCons` com uma string vazia `""`.
  
  uma aplicação para elas já que nós queremos outra função

## 3.8 Let e Where 

### 3.8.1 Let bindings

Muitas vezes nós precisamos guardar valores intermediários que vão nos ajudar a escrever programas menores e mais simples e é para isso que serve o `let`! Vamos começar por um termo bem grande como `(a + 4)*b + ((a + 4)*b)/10`. Para deixar esse termo mais simples e mais legível, podemos abstrair o termo `(a + 4)*b` em um `let` binding e fazer nosso programa mais simples.

```idris
let simple = (a + 4)*b in 
simple + simple/10
``` 

Uma expressão `let` sempre começa com o nome e o valor que ela representa. Após isso nós colocamos o `ìn` que é obrigatório e isso especifica que a variável `simple` está disponível na expressão `simple + simple/10`. Também é possível fazer múltiplos valores num só let binding como em:

```idris
let a = 3
    b = 4
in a + b
```

Há casos especiais onde não precisamos colocar o `in` mas isso vai ficar para o próximo capítulo. 

### 3.8.2 Where 

Where tem um principio de funcionamento bem próximo ao do let, porém, para declarar estruturas de "top-level" da linguagem dentro dele. No exemplo abaixo, iremos usar uma função dentro do `where` para ajudar nossa função principal a cumprir a sua tarefa.

No código abaixo, iremos criar uma função que calcula o fatorial de um número `n`. Porém, o diferencial dessa função é que, ao contrário de usarmos o formato mais simples de cálculo de fatorial que é `fac(x) = x * fac(x-1)` (para x > 0), nós iremos usar um formato que o resultado irá ficar armazenado no parâmetro. Esse formato é `fac(x, acumulador) = fac(x-1, x * acumulador)` que funciona do mesmo jeito, porém, com um novo parâmetro chamado `acumulador` que irá guardar o resultado para nós. 

```idris
fatorial : Int -> Int 
fatorial n = 
    funcaoAjudante n 1     --  <-- só podemos usar a funçãoAjudante aqui! 
  where                    --      Com o valor inicial 1 já que fatorial de 1 é 1
    -- Essa é uma função ajudante declarada dentro do where então só podemos 
    -- acessar ela na parte de cima caso o primeiro argumento seja zero então
    -- vamos retornar o acumulador
    funcaoAjudante : Int -> Int -> Int
    funcaoAjudante 0 acumulador = acumulador
    funcaoAjudante n acumulador = funcaoAjudante (n-1) (n * acumulador)
```

### 3.9 Cast e The

Às vezes nós precisamos converter tipos de dados e para isso existe a função `cast`. Essa função pega um dado tal como
`"2"` que é do tipo `String` e converte em qualquer tipo que você quiser (desde que exista uma conversão possível entre os tipos que você quer). Mas como especificamos o tipo disso? Há duas formas possíveis:

- Usando o cast, por exemplo, em uma soma: <br>
  ```
    (cast "2") + 3
    └────┬───┘   |
         |      Int
         |
    "2" é do tipo String mas como colocamos um `cast` nele, para a soma não dar erro, 
    Idris2 vai transformar sua String em um Int.
  ```

- Para casos que é impossível do compilador saber qual o tipo, nós usamos a função `the`
  que especifica o tipo para nós como em:
  `the Int (cast "3")`  

### 3.10 Expressão If

Para expressar condições, nós utilizamos a sintaxe `if .. then .. else ...` que significa literalmente `se ... então .. se não ..`. Na condição sempre devemos colocar um termo que resulte em `True` ou `False`, ou seja, do tipo `Bool` e após o `then` e no `else`, devemos colocar sempre o mesmo tipo para evitar com que o tipo resultante seja diferente. Um exemplo disso seria:

`if 2 > 3 then "É verdade" else "É falso"` 

O tipo da condição `2 > 3` é `Bool`, o tipo do dado que vem no then ("É verdade") é `String` e do else ("É falso") também é `String` então estamos indo pelo caminho certo. Ambos os dados que estão no `then` e no `else` serão "retornados" e substituirão a expressão como em:

```idris
let resultado = if 2 > 3 then "É verdade" else "É falso"
```

Como `2` é menor que `3` então o valor de `resultado` é `"É falso"`.

Podemos utilizar o `if` para modificar o comportamento da função. No exemplo em que colocamos `1` ao invés de `x` para caso o valor do resultado seja 1, nós podemos reescrever com `if`.

```idris
-- Função original
fatorial : Int -> Int
fatorial 1 = 1
fatorial x = x * fatorial (x - 1)

-- Com If
fatorial : Int -> Int
fatorial x = 
  if x <= 1 
    then 1
    else x * fatorial (x - 1)
```

<a align="end" href="https://github.com/felipegchi/Idris2Noobs/blob/main/1.Introducao/4.io.md">
 PROXIMO
</a> 